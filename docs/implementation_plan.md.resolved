# Day 2 Implementation Plan: Step-by-Step Algorithm Explanations

**Goal**: Enable learners to understand **why** the algorithm makes each decision by adding live trace collection, human-readable explanation templates, and a minimal UI panel to display step-by-step reasoning during algorithm execution.

---

## Overview

Day 2 implements the **Step-by-Step Reasoning** feature, which consists of three core components:

1. **Trace Layer**: Minimal instrumentation of algorithms to log key events
2. **Explanation Layer**: Template-based translation of trace events into Feynman-simple English
3. **UI Panel**: Right sidebar that displays current step, node info, and explanations

**Philosophy**: Keep algorithm changes minimal (optional `trace` parameter), use simple template strings (no AI for live explanations), and create a toggle-able UI that doesn't interfere with existing aesthetics.

---

## User Review Required

> [!IMPORTANT]
> **No Breaking Changes**: All algorithm modifications are **backward-compatible**. The `trace` parameter is optional; if not provided, algorithms run exactly as before.

> [!IMPORTANT]
> **UI Toggle**: The explanation panel will have a show/hide toggle in the navbar, defaulting to **visible** for first-time users but respecting localStorage preferences.

> [!WARNING]
> **Performance**: Trace collection adds ~5-10% overhead during execution. For very large grids (>100x100), this may be noticeable. MVP accepts this tradeoff; optimization is post-MVP.

---

## Proposed Changes

### Component 1: Algorithm Trace Collection

Modify all 8 pathfinding algorithms to accept an optional `trace` array parameter. When provided, algorithms push structured event objects at key decision points.

---

#### [MODIFY] [weightedSearchAlgorithm.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/weightedSearchAlgorithm.js)

**Changes**:
- Add `trace` as the last parameter: `function weightedSearchAlgorithm(nodes, start, target, nodesToAnimate, boardArray, name, heuristic, weight, trace)`
- Add trace events at 5 key points:
  1. **Loop start**: `select_current` when choosing the node with minimum distance/totalDistance
  2. **Neighbor evaluation start**: `evaluating_neighbors` before the neighbor loop
  3. **Relaxation success**: `relax_neighbor` when a shorter path is found
  4. **Skip neighbor**: `skip_neighbor` when a neighbor is ignored (wall, visited, or no improvement)
  5. **Target found**: `found_target` when `currentNode === target`

**Trace Event Schema**:

```javascript
// Event 1: select_current
if (trace) {
  trace.push({
    t: "select_current",
    step: trace.length,
    current: currentNode.id,
    reason: name === "Dijkstra" ? "min_distance" : "min_total_distance",
    metrics: {
      frontierSize: unvisitedNodes.length,
      visitedCount: nodesToAnimate.length
    },
    values: {
      g: currentNode.distance,
      h: currentNode.heuristicDistance || 0,
      f: currentNode.totalDistance
    }
  });
}

// Event 2: evaluating_neighbors
if (trace) {
  trace.push({
    t: "evaluating_neighbors",
    step: trace.length,
    current: currentNode.id,
    neighborCount: currentNeighbors.length
  });
}

// Event 3: relax_neighbor
if (trace) {
  trace.push({
    t: "relax_neighbor",
    step: trace.length,
    from: currentNode.id,
    to: neighbor.id,
    old: { g: neighbor.distance, f: neighbor.totalDistance },
    new: { g: newDistance, f: newDistance + neighbor.heuristicDistance },
    components: {
      base: 1,
      turnPenalty: weightAdditive,
      weight: neighbor.weight > 0 ? neighbor.weight : 0
    },
    why: "new_cost_lower"
  });
}

// Event 4: skip_neighbor
if (trace) {
  var reason = isNeighborWall(neighbor, boardArray) ? "wall"
    : neighbor.status === "visited" ? "visited"
    : "no_improvement";
  trace.push({
    t: "skip_neighbor",
    step: trace.length,
    from: currentNode.id,
    to: neighbor.id,
    reason: reason
  });
}

// Event 5: found_target
if (currentNode === target) {
  if (trace) {
    trace.push({
      t: "found_target",
      step: trace.length,
      target: target.id,
      metrics: {
        visitedCount: nodesToAnimate.length,
        pathCost: target.distance
      }
    });
  }
  return true;
}
```

**Integration Points**:
- Insert trace calls **immediately after** key decisions (e.g., after `currentNode = closestNode`, after `neighbor.distance = newDistance`)
- Keep trace logic wrapped in `if (trace)` guards to ensure zero overhead when not collecting

---

#### [MODIFY] [astar.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/astar.js)

**Changes**: Same as [weightedSearchAlgorithm.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/weightedSearchAlgorithm.js), but:
- Use `"min_total_distance"` as the `reason` in `select_current` (A* always uses f(n))
- Ensure `values.h` reflects the heuristic used (Manhattan, Euclidean, etc.)

---

#### [MODIFY] [unweightedSearchAlgorithm.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/unweightedSearchAlgorithm.js)

**Changes**:
- Add `trace` as the last parameter: `function unweightedSearchAlgorithm(nodes, start, target, nodesToAnimate, boardArray, algorithm, trace)`
- Trace events:
  1. **BFS**: `select_current` (FIFO queue), `skip_neighbor` (wall/visited), `found_target`
  2. **DFS**: `select_current` (LIFO stack), `skip_neighbor` (wall/visited), `found_target`
- **No `relax_neighbor`** events (BFS/DFS don't update distances)
- Use `reason: "fifo_queue"` for BFS, `reason: "lifo_stack"` for DFS

---

#### [MODIFY] [bidirectional.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/bidirectional.js)

**Changes**:
- Add `trace` parameter: `function bidirectional(nodes, start, target, nodesToAnimate, boardArray, name, heuristic, weight, trace)`
- Trace **both directions** with a [direction](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/bidirectional.js#3-45) field:
  - `direction: "forward"` for start → target
  - `direction: "backward"` for target → start
- Add `found_midpoint` event when the two frontiers meet

**Example**:
```javascript
if (trace) {
  trace.push({
    t: "select_current",
    step: trace.length,
    direction: "forward",
    current: currentNode.id,
    reason: "min_distance"
  });
}
```

---

### Component 2: Explanation Templates

Create a utility module that converts trace events into human-readable explanations using simple template strings.

---

#### [NEW] [explanationTemplates.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/utils/explanationTemplates.js)

**Purpose**: Map trace event types to Feynman-simple English templates.

**API**:
```javascript
function generateExplanation(event) {
  // Returns a string like "Selected node (10,15) because it has the lowest total cost so far (f=27)."
}

module.exports = { generateExplanation };
```

**Templates**:

```javascript
function generateExplanation(event) {
  var templates = {
    select_current: function(e) {
      var coords = idToCoords(e.current);
      if (e.reason === "min_distance") {
        return "Selected node " + coords + " because it has the lowest distance from start (g=" + e.values.g + ").";
      } else if (e.reason === "min_total_distance") {
        return "Selected node " + coords + " because it has the lowest total cost (f=" + e.values.f + " = g:" + e.values.g + " + h:" + e.values.h + ").";
      } else if (e.reason === "fifo_queue") {
        return "Selected node " + coords + " from the front of the queue (BFS explores level-by-level).";
      } else if (e.reason === "lifo_stack") {
        return "Selected node " + coords + " from the top of the stack (DFS explores depth-first).";
      }
      return "Selected node " + coords + ".";
    },
    
    evaluating_neighbors: function(e) {
      var coords = idToCoords(e.current);
      return "Checking " + e.neighborCount + " neighbors of " + coords + ".";
    },
    
    relax_neighbor: function(e) {
      var fromCoords = idToCoords(e.from);
      var toCoords = idToCoords(e.to);
      var costBreakdown = "base=" + e.components.base;
      if (e.components.turnPenalty > 0) {
        costBreakdown += " + turn=" + e.components.turnPenalty;
      }
      if (e.components.weight > 0) {
        costBreakdown += " + weight=" + e.components.weight;
      }
      return "Found shorter path to " + toCoords + " via " + fromCoords + ". New cost: " + e.new.g + " (" + costBreakdown + "). Old cost: " + e.old.g + ".";
    },
    
    skip_neighbor: function(e) {
      var toCoords = idToCoords(e.to);
      if (e.reason === "wall") {
        return "Skipped " + toCoords + " because it's a wall.";
      } else if (e.reason === "visited") {
        return "Skipped " + toCoords + " because it's already visited.";
      } else if (e.reason === "no_improvement") {
        return "Skipped " + toCoords + " because the new cost is not better.";
      }
      return "Skipped " + toCoords + ".";
    },
    
    found_target: function(e) {
      var coords = idToCoords(e.target);
      return "Target " + coords + " reached! Visited " + e.metrics.visitedCount + " nodes. Total path cost: " + e.metrics.pathCost + ".";
    },
    
    found_midpoint: function(e) {
      var coords = idToCoords(e.midpoint);
      return "Both searches met at " + coords + "! Combining paths.";
    }
  };
  
  var handler = templates[event.t];
  return handler ? handler(event) : "Step " + event.step;
}

function idToCoords(id) {
  var parts = id.split("-");
  return "(" + parts[0] + "," + parts[1] + ")";
}
```

**Key Design Decisions**:
- **No conditionals in templates**: Use separate handlers per event type
- **Feynman-simple**: Use "shortest path" not "relaxation", "cost" not "distance"
- **No jargon**: Avoid terms like "frontier", "heuristic admissibility", etc.
- **Explicit units**: Always show what the numbers mean (g=, f=, h=)

---

### Component 3: UI Explanation Panel

Add a right sidebar panel that displays the current step's explanation, node details, and algorithm metrics.

---

#### [MODIFY] [index.html](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/index.html)

**Changes**:

1. **Add toggle button to navbar** (after algorithm dropdown):
```html
<li id="explanationToggle" class="navbar-button">
  <button id="toggleExplanationBtn" class="btn btn-default navbar-btn">
    <span class="glyphicon glyphicon-info-sign"></span> Step Explanations
  </button>
</li>
```

2. **Add explanation panel** (after `#mainGrid`, before closing `.container`):
```html
<div id="explanationPanel" class="explanation-panel">
  <div class="explanation-header">
    <h4>Step-by-Step Reasoning</h4>
    <button id="closeExplanationBtn" class="close-btn">&times;</button>
  </div>
  
  <div class="explanation-content">
    <div class="section">
      <h5>Current Step</h5>
      <div id="stepNumber" class="metric">—</div>
    </div>
    
    <div class="section">
      <h5>Current Node</h5>
      <div id="currentNodeInfo" class="node-info">
        <div class="node-coords">—</div>
        <div class="node-costs">
          <span class="cost-label">g:</span> <span id="gCost">—</span>
          <span class="cost-label">h:</span> <span id="hCost">—</span>
          <span class="cost-label">f:</span> <span id="fCost">—</span>
        </div>
      </div>
    </div>
    
    <div class="section">
      <h5>What's Happening?</h5>
      <div id="explanationText" class="explanation-text">
        No algorithm running. Click "Visualize Algorithm!" to start.
      </div>
    </div>
    
    <div class="section">
      <h5>Algorithm Metrics</h5>
      <div class="metrics-grid">
        <div class="metric-item">
          <span class="metric-label">Frontier Size:</span>
          <span id="frontierSize">—</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Visited Count:</span>
          <span id="visitedCountLive">—</span>
        </div>
      </div>
    </div>
  </div>
</div>
```

---

#### [MODIFY] [cssBasic.css](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/styling/cssBasic.css)

**Changes**: Append styles for the explanation panel.

```css
/* ============================================
   EXPLANATION PANEL STYLES
   ============================================ */

.explanation-panel {
  position: fixed;
  top: 50px; /* Below navbar */
  right: 0;
  width: 320px;
  height: calc(100vh - 50px);
  background: #ffffff;
  border-left: 2px solid #3498db;
  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
  overflow-y: auto;
  z-index: 900;
  transition: transform 0.3s ease-in-out;
  display: flex;
  flex-direction: column;
}

.explanation-panel.hidden {
  transform: translateX(100%);
}

.explanation-header {
  background: #3498db;
  color: white;
  padding: 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #2980b9;
  flex-shrink: 0;
}

.explanation-header h4 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.close-btn {
  background: transparent;
  border: none;
  color: white;
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  width: 30px;
  height: 30px;
  line-height: 30px;
  text-align: center;
  transition: background 0.2s;
  border-radius: 3px;
}

.close-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.explanation-content {
  padding: 15px;
  flex-grow: 1;
  overflow-y: auto;
}

.section {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #ecf0f1;
}

.section:last-child {
  border-bottom: none;
}

.section h5 {
  margin: 0 0 10px 0;
  font-size: 14px;
  font-weight: 600;
  color: #2c3e50;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.metric {
  font-size: 24px;
  font-weight: 700;
  color: #3498db;
}

.node-info {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.node-coords {
  font-size: 18px;
  font-weight: 600;
  color: #2c3e50;
}

.node-costs {
  display: flex;
  gap: 12px;
  font-size: 14px;
}

.cost-label {
  font-weight: 600;
  color: #7f8c8d;
}

#gCost, #hCost, #fCost {
  font-weight: 700;
  color: #3498db;
}

.explanation-text {
  font-size: 14px;
  line-height: 1.6;
  color: #34495e;
  background: #ecf0f1;
  padding: 12px;
  border-radius: 4px;
  border-left: 3px solid #3498db;
}

.metrics-grid {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.metric-item {
  display: flex;
  justify-content: space-between;
  font-size: 14px;
}

.metric-label {
  color: #7f8c8d;
  font-weight: 500;
}

#frontierSize, #visitedCountLive {
  font-weight: 700;
  color: #3498db;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .explanation-panel {
    width: 100%;
    top: 50px;
  }
}

/* Dark mode support (if you add it later) */
@media (prefers-color-scheme: dark) {
  .explanation-panel {
    background: #2c3e50;
    border-left-color: #3498db;
  }
  
  .explanation-header {
    background: #34495e;
    border-bottom-color: #2c3e50;
  }
  
  .section {
    border-bottom-color: #34495e;
  }
  
  .section h5 {
    color: #ecf0f1;
  }
  
  .node-coords {
    color: #ecf0f1;
  }
  
  .explanation-text {
    background: #34495e;
    color: #ecf0f1;
  }
}
```

---

#### [MODIFY] [board.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/board.js)

**Changes**:

1. **Add UI controller for explanation panel**:
```javascript
// After currentWeightValue initialization
this.explanationPanelVisible = localStorage.getItem("explanationPanelVisible") !== "false"; // Default true
this.currentTrace = []; // Trace array for current run

// Initialize panel visibility
var panel = document.getElementById("explanationPanel");
if (!this.explanationPanelVisible) {
  panel.classList.add("hidden");
}
```

2. **Add toggle event listeners** (in constructor):
```javascript
document.getElementById("toggleExplanationBtn").addEventListener("click", function() {
  currentObject.toggleExplanationPanel();
});

document.getElementById("closeExplanationBtn").addEventListener("click", function() {
  currentObject.toggleExplanationPanel();
});
```

3. **Add toggle method**:
```javascript
Board.prototype.toggleExplanationPanel = function() {
  this.explanationPanelVisible = !this.explanationPanelVisible;
  var panel = document.getElementById("explanationPanel");
  panel.classList.toggle("hidden");
  localStorage.setItem("explanationPanelVisible", this.explanationPanelVisible);
};
```

4. **Add update method** (called from animation loop):
```javascript
Board.prototype.updateExplanationPanel = function(event) {
  if (!event) {
    // Reset panel
    document.getElementById("stepNumber").textContent = "—";
    document.getElementById("currentNodeInfo").querySelector(".node-coords").textContent = "—";
    document.getElementById("gCost").textContent = "—";
    document.getElementById("hCost").textContent = "—";
    document.getElementById("fCost").textContent = "—";
    document.getElementById("explanationText").textContent = "No algorithm running.";
    document.getElementById("frontierSize").textContent = "—";
    document.getElementById("visitedCountLive").textContent = "—";
    return;
  }
  
  var explanationTemplates = require("./utils/explanationTemplates.js");
  var explanation = explanationTemplates.generateExplanation(event);
  
  document.getElementById("stepNumber").textContent = event.step;
  document.getElementById("explanationText").textContent = explanation;
  
  // Update node info if event has a 'current' field
  if (event.current) {
    var coords = event.current.replace("-", ",");
    document.getElementById("currentNodeInfo").querySelector(".node-coords").textContent = "(" + coords + ")";
  }
  
  // Update costs if available
  if (event.values) {
    document.getElementById("gCost").textContent = event.values.g || "—";
    document.getElementById("hCost").textContent = event.values.h || "—";
    document.getElementById("fCost").textContent = event.values.f || "—";
  }
  
  // Update metrics if available
  if (event.metrics) {
    document.getElementById("frontierSize").textContent = event.metrics.frontierSize || "—";
    document.getElementById("visitedCountLive").textContent = event.metrics.visitedCount || "—";
  }
};
```

5. **Clear trace on new run** (in [clearPath](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/board.js#417-480), [clearWalls](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/board.js#481-493), algorithm launcher methods):
```javascript
this.currentTrace = [];
this.updateExplanationPanel(null); // Reset panel
```

---

#### [MODIFY] [launchAnimations.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/animations/launchAnimations.js)

**Changes**:

1. **Pass trace to algorithms**:
```javascript
// In Board.prototype.findShortestPath()
var trace = this.currentTrace;
success = weightedSearchAlgorithm(
  this.nodes,
  this.nodes[this.start],
  this.nodes[this.target],
  nodesToAnimate,
  this.boardArray,
  this.currentAlgorithm,
  this.currentHeuristic,
  weight,
  trace // <-- Add this
);
```

2. **Update panel during animation**:
```javascript
// In timeout() function, after animating a node
if (board.currentTrace && board.currentTrace.length > 0) {
  // Find the trace event corresponding to this animation frame
  // This is approximate; we sync by counting nodesToAnimate vs trace events
  var traceIndex = Math.min(index, board.currentTrace.length - 1);
  var event = board.currentTrace[traceIndex];
  board.updateExplanationPanel(event);
}
```

**Note**: The mapping between animation frames and trace events is **approximate** in MVP. Trace events may be generated at different rates than animation frames. For Day 2 MVP, we'll show the "closest" trace event. Perfect synchronization is a post-MVP enhancement.

---

### Component 4: Integration & Wiring

Ensure all 8 algorithms are updated and the UI updates correctly during animation.

---

#### [MODIFY] All remaining algorithm files

Apply the same trace instrumentation pattern to:
- [weightedSearchAlgorithm.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/weightedSearchAlgorithm.js) (Dijkstra, Greedy, Swarm, Convergent Swarm)
- [astar.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/astar.js)
- [unweightedSearchAlgorithm.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/unweightedSearchAlgorithm.js) (BFS, DFS)
- [bidirectional.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/pathfindingAlgorithms/bidirectional.js)

---

#### [MODIFY] [board.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/board.js)

**Additional changes**:
- Ensure `this.currentTrace` is passed to **all** algorithm calls (not just weighted ones)
- Clear trace in [clearPath()](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/board.js#417-480), `clearBoard()`, `resetGrid()`
- Reset explanation panel when no algorithm is running

---

## Verification Plan

### Automated Tests

**Manual Browser Testing** (no unit tests for MVP):

1. **Trace Collection**:
   - Run Dijkstra on a 20x20 grid with walls and weights
   - Open browser console, inspect `newBoard.currentTrace`
   - Verify array contains `select_current`, `relax_neighbor`, `skip_neighbor`, `found_target` events
   - Check that event counts are reasonable (≈ visited nodes count)

2. **Explanation Panel UI**:
   - Verify panel appears on page load (right sidebar)
   - Click toggle button, verify panel slides in/out
   - Verify localStorage persists visibility preference
   - Run algorithm, verify panel updates in real-time with step numbers, node coords, and explanations

3. **All Algorithms**:
   - Run each of the 8 algorithms (Dijkstra, A*, BFS, DFS, Greedy, Swarm, Convergent Swarm, Bidirectional)
   - Verify trace events are logged for each
   - Verify explanations are generated (check console for errors)
   - Verify panel displays correct algorithm-specific text (e.g., "FIFO queue" for BFS, "min total cost" for A*)

4. **Performance**:
   - Run Dijkstra on a 50x50 grid
   - Verify animation completes without freezing
   - Check that trace collection doesn't cause noticeable slowdown (<10% overhead)

### Manual Verification

1. **Navbar Toggle**:
   - [ ] Toggle button has info icon + "Step Explanations" text
   - [ ] Clicking toggle shows/hides panel smoothly
   - [ ] Panel state persists across page reloads

2. **Panel Content**:
   - [ ] "Current Step" shows incrementing step number
   - [ ] "Current Node" shows correct (row, col) coordinates
   - [ ] g, h, f costs update correctly (h=0 for Dijkstra, h>0 for A*)
   - [ ] "What's Happening?" text is in Feynman-simple English
   - [ ] Frontier size and visited count update in real-time

3. **Explanation Quality**:
   - [ ] No jargon (avoid "relaxation", "frontier", "admissibility")
   - [ ] Numbers have units (g=27, not just 27)
   - [ ] Sentences are complete and grammatically correct
   - [ ] Cost breakdowns are accurate (base + turn + weight)

4. **Edge Cases**:
   - [ ] Panel handles "no path found" gracefully
   - [ ] Panel resets when "Clear Path" is clicked
   - [ ] Panel works correctly when algorithm is changed mid-run (if user clicks "Visualize" twice)
   - [ ] Panel doesn't interfere with grid click events

---

## Out of Scope (Day 2 MVP)

- **Perfect animation/trace synchronization**: Trace events and animation frames may not align 1:1
- **Play/Pause controls**: Autoplay only; manual stepping is post-MVP
- **Trace export**: Saving trace to file or sharing is Day 3+
- **AI-generated explanations**: Live explanations use templates only; AI is for post-run summaries (Day 3)
- **Mobile optimization**: Panel may overlap grid on small screens; acceptable for MVP
- **Accessibility**: ARIA labels, keyboard navigation are post-MVP
- **Dark mode**: Explanation panel uses light theme only for MVP

---

## Success Criteria

After Day 2, a learner should be able to:
- **See** what node the algorithm is currently evaluating
- **Understand** why that node was chosen (e.g., "lowest cost so far")
- **Learn** how edge costs are computed (base + turn + weight breakdown)
- **Recognize** when neighbors are skipped and why (wall, visited, no improvement)
- **Toggle** the explanation panel off to focus on the visual animation alone

---

## Dependencies

- **Day 1 complete**: Weight slider, path cost display, run serialization, localStorage history
- **Browserify rebuild**: After adding `explanationTemplates.js`, run `npm run watch` to regenerate [bundle.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/bundle.js)
- **jQuery**: Used for DOM manipulation in [board.js](file:///Users/truongphuc/Desktop/8:10/Pathfinding-Visualizer/public/browser/board.js) event listeners
- **Bootstrap**: No additional dependencies; uses existing grid system

---

## Risk Mitigation

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Trace overhead slows animation | Medium | Medium | Make trace optional; skip for instant mode |
| Animation/trace desync | High | Low | Accept approximate sync for MVP; document limitation |
| Panel overlaps grid on small screens | High | Low | Add media query to hide/collapse panel on mobile |
| Explanation text too technical | Medium | High | Use Feynman test: "Would a 10-year-old understand this?" |
| User closes panel and can't reopen | Low | Medium | Ensure toggle button is always visible in navbar |

---

## Next Steps (Post-Day 2)

After completing Day 2 implementation:
1. **Verify** all 8 algorithms log trace events correctly
2. **Test** explanation panel on all screen sizes
3. **Request user feedback** on explanation clarity
4. **Proceed to Day 3**: AI post-run explanation, History UI, replay functionality
